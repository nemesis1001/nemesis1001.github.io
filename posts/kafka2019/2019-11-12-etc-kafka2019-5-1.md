---
layout: post
title:  "[More Kafka]5-1. 카프카 매커니즘"
subtitle:   "[More Kafka]5-1. 카프카 매커니즘"
description : "[More Kafka]5-1. 카프카 매커니즘"
keywords : "msa, kafka, zookeeper, 주키퍼, 카프카, 도커, 주키퍼 도커 설치, 카프카 도커, 주키퍼 docker compose, 카프카 docker compose, 도커로 주키퍼 카프카 설치, docker compose zookeeper, docker compose kafka, 컨플루언트, confluent, kafka multi node, consumer, kafka consumer, consumer 옵션, kafka consumer 설정, 컨슈머, 카프카 컨슈머, znode, 카프카 지노"
categories: etc
tags: kafka
comments: true
---

## 주키퍼 znode

### 살펴보기

```
최상위 root를 kafka-main 이라고 하면

/kafka-main/controller (컨트롤러 정보)
		   /brokers/id (브로커 정보, 브로커 고유번호)
				   /topics (토픽의 설정 정보)
		   /config
```

### 설명
- 브로커 프로세스는 시작될 때마다 /broker/id 에 임시 노드로 자신의 ID를 등록하게 됨
- 같은 ID 등록시 Error
- 브로커 연결이 끊어지거나 종료시에는 자동으로 주키퍼에서 노드는 삭제된다

 ## 컨트롤러
 - 파티션 리더를 선출하는 책임을 가진 브로커
 - 클러스터에서 시작하는 첫 번째 브로커가 컨트롤러가 된다
 - 다른 브로커들이 시작될 때도 /controller 생성을 하려고 시도 -> 이미 첫 번째 브로커가 시작되었다면 /controller가 생성되었다는 예외를 받게되며, controller 가 생성된 것을 알 수 있게된다
- 컨트로러가 새롭게 선출될 때마다 새로운 **컨트롤러 세대 번호** 를 받는다
- 컨트롤러가 아닌 브로커들은 컨트롤러 세대 번호로 현재 유지되는 컨트롤커 브로커를 알 수 있음

## 복제

### 리더 리플리카(leader replica)
- 각 파티션은 리더로 지정된 하나의 리플리카를 갖는다. 일관성을 위해서 producer와 consumer의 요청은 리더를 통해서 진행된다

### 팔로워 리플리카(follower replica)
- 파티션 리더를 제외한 나머지를 말한다
- 리더의 메세지를 복제한다
- 리더 리플리카 장애시 팔로워 리플리카 중 하나가 리더로 승격된다

### 팔로워 리플리카의 동작방식
- 리더에게 Fetch 요청 (리더와 동기화를 위해서)
	- Fetch 요청에는 리플리카가 다음으로 받기 원하는 오프셋 정보가 포함되어 있다
	- Consumer가 메세지를 읽기 위해서 전송하는 것과 동일한 타입의 요청임
- 리더는 리플리카에게 메시지를 전송함

```
follower ->  leader 에게 fetch 요청

팔로워가 10초 이상 데이터 처리를 못하고 요청을 안하게 되면 Out-Sync가 되며, 추후 리더 자격 박탈
이와 반대로 팔로워가 계속 정상적으로 메시지를 요청하는 것을 In Sync Replica(ISR)이라고 하며
ISR 이라는 그룹에 유지가 되는 팔로워는 추후 리더의 자격을 갖춘 것으로 판단한다
```

## 쓰기요청
- 기본적으로 ack 옵션을 주어서 브로커에 메시지 쓰기 설정(?)을 제어할 수 있다.
- 브로커는 쓰기요청을 받으면 아래의 세가지를 먼저 검사한다
	- 데이터 전송자가 토픽의 쓰기 권한을 가지고 있는가?
	- ack 옵션이 가능한가?
	- `ack = all` 이라면 동기화 처리를 해줘야 하는 리플리카가 충분한지 파악한다. 동기화 리플리카들의 개수가 구성 가능한 개수보다 작으면 새로운 메시지가 거부될 수 있음
- 세 가지 검사 이후에 디스크에 메시지를 쓰게 된다.

## 읽기요청
- 클라이언트(컨슈머)는 필수 메타데이터를 요청함
- 리더는 해당 메타데이터 기준으로 적합여부를 검사함. 예를 들어서 해당 파티션의 오프셋이 있는지. 등
- 삭제된 오프셋의 경우에는 에어를 응답한다
- 오프셋이 존재하면 클라이언트가 **지정한 크키 혹은 적어도 (이만큼) 크기** 만큼 파티션에서 읽은 후 클라이언트에게 전송함
	- 참고로 전송은 어떤 버퍼 메모리에 쓰지않고, 곧바로 네트워크 채널로 전송함(= 제로카피 기법)

![](https://github.com/twowinsh87/twowinsh87.github.io/blob/master/assets/kafka_img/2019kafka-5-1.jpeg?raw=true)

- 참고) 모든 동기화(팔로워) 리플리카들이 새로운 메시지에 대한 복제가 이루어지지 않은 상태에서 클라이언트 요청이 들어오면 클라이언트에게 빈 응답을 주게된다
	- 리더는 데이터를 가지고 있지만 복제가 안된 메시지(상황)을 **불안정한** 것으로 간주한다.

## 스토리지

### 파티션 할당 / 파일관리
- 여러 브로커 간에 파티션을 할당하는 방법 = 기본적으로 라운드 로빈
- 스토리지로 렉을 사용하고 있다면 0.10.0 이상의 kafka 버전에서 랙-인식(rack-aware)을 고려한다 p121

### 파일관리
- 레코드 / 레코드배치 / 세그먼트 / 파티션 단위를 알아야함
- 자세한 내용은 추가로 정리

### 파일 형식
- 세그먼트는 하나의 데이터파일(카프카 메시지 + 오프셋)임을 인지
- 압축 전송을 권장
- 아래는 압축된 메시지의 형태를 볼 수 있다

![](https://github.com/twowinsh87/twowinsh87.github.io/blob/master/assets/kafka_img/2019kafka-5-2.jpeg?raw=true)
