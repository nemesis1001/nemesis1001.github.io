---
layout: post
title:  "Java week2"
subtitle:   "Java week2"
keywords : "자바 스터디, 프리미티브 타입, 레퍼런스 타입, 리러털, 변수 선언, 변수의 스코프와 라이프타임, 1차원 배열, 2차원 배열, 타입 추론, var"
categories: language
tags: java
comments: true
---

> ## 2주차
> 프리미티브 타입 종류와 값의 범위 그리고 기본 값    
> 프리미티브 타입과 레퍼런스 타입   
> 리터럴   
> 변수 선언 및 초기화하는 방법   
> 변수의 스코프와 라이프타임   
> 타입 변환, 캐스팅 그리고 타입 프로모션   
> 1차 및 2차 배열 선언하기   
> 타입 추론, var   


## 1. 프리미티브 타입 종류와 값의 범위 그리고 기본 값
- 프리미티브 타입은 정수, 실수, 논리, 문자를 직접 저장하는 타입을 말함
- 정해진 메모리 사용 크기로 값을 저장함
- 범위를 초과하는 경우 `Type:mismatch: cannot convert form ? to ?` 에러
- 프리미티브 타입은 기본값이 있으므로 null이 존재하지 않음

|종류|기본타입|메모리 사용 크기|저장되는 값의 범위|기본값|
|------|-----|-----|------|------|
|정수|byte|1byte|-128 ~ 127|0|
|정수, 문자|char|2byte|0 ~ 65535|0|
|정수|short|2byte|-32,768 ~. 2.767|0|
|정수|int|4byte|-2,147,483,648 ~ 2,147,483,647|0|
|정수|long|8byte|-2^63 ~ (2^63-1)|0L|
|실수|float|4byte|(+/-)1.4E-45 ~ (+/-)3.4028235E38|0.0F|
|실수|double|8byte|(+/-)4.9E-324 ~ (+/-)1.7976931348623157E308|0.0|
|논리|boolean|1byte|true, false|false|

** 2^n 에서 n 은 메모리 사용크기로 bit를 나타냄.

- `byte`: 가장 작은 정수 타입을 저장. 최상위 비트가 양수, 음수를 결정하여 -2^7 ~ (2^7-1) 범위를 가진다.
- `char`: 자바는 기본적으로 문자를 유니코드(0~65535)로 처리. 한글을 포함한 모든 문자는 2byte 크기를 가진 정수이다. 문자를 직접 저장 or 10진수 저장 or 16진수 '\u+16진수값' 으로 저장
- `short`: C언어와 호환을 위해 사용되며 비교적 자바에서는 안쓰인다고 한다.(책에서..)
- `int`: 자바에서 정수 기본연산의 단위이다. byte + short 하면 int로 변환되어 계산하고 int로 리턴된다. 정수 연산을 4byte로 처리하기 때문에 int를 사용한다고 성능 차이가 있다고 보기 힘들 것 같다.
- `long`: 정수 값에 소문자 엘(l) 이나 L을 뒤에 붙여야 한다.
- `float`: int와 같이 4byte로 메모리 저장 크기가 같으나 부동 소수점 방식으로 저장되므로 같은 메모리에 더 큰 범위의 값을 저장할 수 있다. 값 뒤에 f 나 F를 붙여야 한다.
- `double`: 정수의 int 처럼 자바에서 실수 리터럴의 기본 타입을 double로 간주 함.


## 2. 프리미티브 타입과 레퍼런스 타입
### 프리미티브 타입
- 미리 정의된 기본 타입을 말한다
- Stack 메모리에 직접 값이 할당된다 

### 레퍼런스 타입
- 말그대로 참조형 타입으로 프리미티브 타입을 제외한 모든 타입을 말한다
- Heap 메모리에 할당되며 객체의 주소값을 가지고 있는다(4byte)
	- ex) array, enum, class, interface
- 런타임 에러가 발생할 수 있음.

## 3. 리터럴
- 소스 코드에서 직접 입력된 값을 리터럴(literal)이라고 함. 변수의 초기값으로 많이 사용됨
	- 정수 리터럴, 실수 리터럴, 문자 리터럴, 논리 리터럴
- 상수와 다른 점은 값을 변경할 수 있다는 점에서 다르다고 본다
- 정해진 표기법이 있으며, 표기법대로 작성해야한다

### 정수 리터럴(byte, char, short, int, long)
- `0, 75, -100`: 소수점이 없는 경우 10진수로 간주
- `02, -04`: 0으로 시작. 8진수
- `0x5, 0xB3`: 0x로 시작, A~F, a~f는 16진수로 간주

### 실수 리터럴(float, double)
- `0.25, -3,14`: 10진수 실수로 간주
- `5E7, 0.12E-5`: 5 x 10^7 ,  0.12 x 10^-5 즉 E, e를 포함한 표기는 10진수 지수와 가수로 본다

### 문자(열) 리터럴
- `'ㅁ', '\t, 'A'`: 작은 따옴표(')로 묶은 텍스트는 하나의 문자 리터럴
- `'\t',''\n', '\r', '\"', '\\', '\u16진수'`: \가 붙은 문자 리터럴이며, 이스케이프 문자로 불리우며 각각 용도가 다르다.
- `"가나 다라 "`: 큰 따옴표(")를 붙인 것은 문자열 리터럴로 간주.

### 논리 리터럴
- `ture, false`


## 4. 변수 선언 및 초기화하는 방법

```
(1)
int count;
count = 100;

(2)
int count = 100;
```


## 5. 변수의 스코프와 라이프타임
- 변수의 스코프: 선언된 블록( { } ) 내에서만 사용이 가능.
- 이 말은 변수는 블록 내에서 라이프 타임이 존재한다. 
- static 변수는 process의 전체 타임이 라이프 타임. JVM이 시작시 static 변수들은 method 영역에 올라가는..


## 6. 타입 변환, 캐스팅 그리고 타입 프로모션 
### 캐스팅
- 자료형을 변환하는 연산. 범위가 작은 타입에서 큰 타입으로 캐스팅 연산이 가능하다.
- 기본형 변수끼리, 참조형 변수끼리 각각 사용 가능하다.

### 자동 타입 변환(Promotion)
- `암시적 캐스팅` 컴파일러가 자동으로 캐스팅 연산을 수행함
- `큰 크기 타입 = 작은 크기 타입`: 결과적으로 변환 이전의 값과 변환 이후의 값은 동일. 
**참고: byte(1) < short(2) < int(4) < long(8) < float(4) < double(8)

### 강제 타입 변환
- `명시적 캐스팅` 데이터 손실, 불일치가 발생할 수 있는 상황에서 컴파일 에러가 발생하므로 명시적으로 캐스팅 연산자를 프로그래머가 기술
- `작은 크기 타입 = (작은 크기 타입) 큰 크기 타입`: 변환 이전의 값과 변환 이후의 값이 동일하다고 보장할 수 없음. 변환 될 타입의 최소 최대 값을 벗어나는지 확인할 것. ex) `Byte.MAX_VALUE Byte.MIN_VALUE`

```
int value = 103029770;
byte byteValue = (byte) value;
```

00000110|00100100|00011100|00001010
---- | ---- | ---- | ----
X | X | X | O

- 원래 값(103029770)이 마지막 1byte(00001010)만 보존되어 실제로 십진수: 10 이 됨

### 타입 프로모션
- 연산식에서 캐스팅이 일어나는 경우는 두 연산자 중에서 큰 타입으로 자동 변환된 후 연산을 수행한다. `double d = intValue + doubleValue`


## 7. 1차 및 2차 배열 선언하기
- 배열 변수를 선언 2가지
	- `타입[] 변수`
	- `타입 변수[]`
- 배열 변수는 참초 변수로 null 값으로 초기화될 수 있음. ex) `int[] intArray = null;`
	- 당연히 변수(intArray)를 읽으면 참조 객체가 없으므로 `npe` 발생

- 값 목록으로 배열 생성

```
String[] names;
names = new String[]{"가길동, 나길동, 다길동"};

String[] names = {"가길동, 나길동, 다길동"};

String[][] names = {{"가길동", "나길동"}, {"다길동", "라길동"}};
System.out.println(names[0][0]); // 가길동
System.out.println(names[0][1]); // 나길동
System.out.println(names[1][0]); // 다길동
System.out.println(names[1][1]); // 라길동
System.out.println(names[1][1]); // 라길동
System.out.println(names[1][2]); // ArrayIndexOutOfBoundsException
```


- new 연산자로 배열 생성: 값의 목록은 없지만, 후에 값들을 저장할 배열을 미리 만들고 싶다

```
int[] ages;
ages = new int[5];

int[] ages = new int[5];
int[][] scores = new int[2][3];

int[][] scores = new int[3][];
scores[0] = new int[] {0, 1, 2, 3, 4};
scores[1] = new int[] {5, 6, 7};
scores[2] = new int[] {8, 9, 10, 11, 12, 13, 14, 15, 16};
```


## 8. 타입 추론, var
- 컴파일러가 타입을 유추하는 것으로 Java 10 var 키워드를 사용한다.
 var 는 가변의 타입을 갖는 저장 단위로 선언과 동시에 초기화가 필요하며, 언제라도 변수에 할당한 값은 재할당이 가능하다.


#### 참고
- 이것이 자바다 책
- 변수 라이프 타임 관련 [이 블로그](http://blog.naver.com/PostView.nhn?blogId=hsm622&logNo=222144931396)
